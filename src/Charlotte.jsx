/* eslint-disable react-hooks/exhaustive-deps */
/* eslint-disable no-unused-vars */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 src/assets/charlottee.glb 
*/

import React, { useEffect, useRef, useState } from "react";
import { useFrame, useGraph, useThree } from "@react-three/fiber";
import { useGLTF, useAnimations } from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";
import * as THREE from "three";
import { handlePositionData } from "./helper-functions/handle-position-data";
import { animationPositionHandler } from "./helper-functions/handle-animation-positions";

export function Charlotte({
  characterRef,
  isColliding,
  isCollidingFromBehind,
  distance,
  setShowOverlay,
}) {
  const group = React.useRef();
  const { scene, animations: loadedAnimations } = useGLTF(
    "src/assets/charlotte15.glb"
  );
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone);
  const { actions, mixer } = useAnimations(loadedAnimations, group);
  const [currentAnimation, setCurrentAnimation] = useState("positiveDanceOne");
  const currentAnimationRef = useRef(currentAnimation);
  const currentRotation = useRef("0");
  const savedPositions = useRef(null);

  React.useEffect(() => {
    if (group.current) {
      group.current.traverse((child) => {
        if (child.isMesh) {
          child.frustumCulled = false; // Deaktiviert Frustum Culling
          child.castShadow = true; // Objekt wirft Schatten
          child.receiveShadow = true; // Objekt empfÃ¤ngt Schatten
        }
      });
    }
  }, []);

  React.useEffect(() => {
    handlePositionData(savedPositions, loadedAnimations);
  }, [loadedAnimations]);

  React.useEffect(() => {
    currentAnimationRef.current = currentAnimation;
  }, [currentAnimation]);

  React.useEffect(() => {
    const dance = actions["DanceOne"];
    dance.loop = THREE.LoopOnce;
    dance.clampWhenFinished = true;
    const backwards = actions["Backwards"];
    backwards.loop = THREE.LoopOnce;
    backwards.clampWhenFinished = true;

    if (!dance.isRunning()) {
      dance.play();
    }

    if (isColliding && dance.isRunning() === true) {
      console.log(currentRotation.current);
      if (currentRotation.current === "turned 180") {
        currentRotation.current = "turn to 0";
        setCurrentAnimation("positiveBackwards");
      }

      setCurrentAnimation("positiveBackwards");
      dance.fadeOut(0.5);
      backwards.reset().fadeIn(0.5).play();

      mixer.addEventListener("finished", (event) => {
        if (event.action === backwards) {
          backwards.fadeOut(0.5);
          dance.reset().fadeIn(0.5).play();
          setCurrentAnimation("positiveDanceOne");
        }
      });
    }

    if (isCollidingFromBehind && dance.isRunning() === true) {
      setCurrentAnimation("negativeBackwards");

      setTimeout(() => {
        currentRotation.current = "turn to 180";
        dance.fadeOut(0.5);
        backwards.reset().fadeIn(0.5).play();
      }, 50);

      mixer.addEventListener("finished", (event) => {
        if (event.action === backwards) {
          backwards.fadeOut(0.5);
          dance.reset().fadeIn(0.5).play();
          setCurrentAnimation("negativeDanceOne");
        }
      });
    }
    mixer.addEventListener("finished", (event) => {
      if (event.action === dance) {
        dance.fadeOut(1);
        setTimeout(() => {
          setCurrentAnimation("");
          setShowOverlay(true);
        }, 1500);
      }
    });
  }, [isColliding, isCollidingFromBehind, actions]);

  React.useEffect(() => {
    animationPositionHandler(
      currentAnimation,
      savedPositions,
      group,
      currentAnimationRef
    );
  }, [currentAnimation]);

  useFrame(() => {
    if (currentRotation.current === "turn to 180") {
      if (group.current.rotation.y < Math.PI) {
        group.current.rotation.y += 0.12;
        console.log(group.current.rotation.y);
      }

      setTimeout(() => {
        group.current.rotation.y = Math.PI;
        console.log(group.current.rotation.y);
        currentRotation.current = "turned 180";
      }, 500);
    }

    if (currentRotation.current === "turn to 0") {
      if (group.current.rotation.y > 0) {
        group.current.rotation.y -= 0.12;
        console.log(group.current.rotation.y);
      }

      setTimeout(() => {
        group.current.rotation.y = 0;
        currentRotation.current = "0";
      }, 500);
    }
  });
  return (
    <group ref={group} dispose={null}>
      <group name="Scene">
        <group
          name="ch_charlotte_rig_main"
          rotation={[Math.PI / 2, 0, 0]}
          scale={0.01}
        >
          <group name="ch_charlotte_srf_geo" />
          <group name="scale_reference" scale={0.943}>
            <group name="charlotteRig_Reference">
              <primitive object={nodes.charlotteRig_Hips} ref={characterRef} />
              <group name="ch_charlotte_srf_head" />
              <group name="Mesh" />
              <group name="Mesh001" />
              <group name="Mesh002" />
              <group name="Mesh003" />
              <skinnedMesh
                name="Mesh004"
                geometry={nodes.Mesh004.geometry}
                material={materials.charlotteHeadMat}
                skeleton={nodes.Mesh004.skeleton}
                morphTargetDictionary={nodes.Mesh004.morphTargetDictionary}
                morphTargetInfluences={nodes.Mesh004.morphTargetInfluences}
              />
              <group name="ch_charlotte_eyeL_mesh">
                <skinnedMesh
                  name="Mesh001_1"
                  geometry={nodes.Mesh001_1.geometry}
                  material={materials.corneaMat}
                  skeleton={nodes.Mesh001_1.skeleton}
                />
                <skinnedMesh
                  name="Mesh001_2"
                  geometry={nodes.Mesh001_2.geometry}
                  material={materials.eyeMat}
                  skeleton={nodes.Mesh001_2.skeleton}
                />
              </group>
              <group name="ch_charlotte_eyeR_mesh">
                <skinnedMesh
                  name="Mesh002_1"
                  geometry={nodes.Mesh002_1.geometry}
                  material={materials.corneaMat}
                  skeleton={nodes.Mesh002_1.skeleton}
                />
                <skinnedMesh
                  name="Mesh002_2"
                  geometry={nodes.Mesh002_2.geometry}
                  material={materials.eyeMat}
                  skeleton={nodes.Mesh002_2.skeleton}
                />
              </group>
              <skinnedMesh
                name="ch_charlotte_srf_main"
                geometry={nodes.ch_charlotte_srf_main.geometry}
                material={materials.charlotteBodyMat}
                skeleton={nodes.ch_charlotte_srf_main.skeleton}
                morphTargetDictionary={
                  nodes.ch_charlotte_srf_main.morphTargetDictionary
                }
                morphTargetInfluences={
                  nodes.ch_charlotte_srf_main.morphTargetInfluences
                }
              />
            </group>
          </group>
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("/charlotte15.glb");
