/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 src/assets/lazyAmy.glb 
*/

import React, { useState } from "react";
import { useGraph } from "@react-three/fiber";
import { useGLTF, useAnimations } from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";
import * as THREE from "three";
import gsap from "gsap";

export function LazyAmy({ characterRef, isColliding }) {
  const group = React.useRef();
  const { scene, animations: loadedAnimations } = useGLTF(
    "src/assets/lazyAmy2.glb"
  );
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone);
  const { actions } = useAnimations(loadedAnimations, group);
  const [currentAnimation, setCurrentAnimation] = useState(null);

  //console.log(loadedAnimations);

  //__________________________________________________________________________________________________________
  function removeRootMotionFromClip(clip) {
    clip.tracks = clip.tracks.filter((track) => {
      const isHipsPosition = track.name.endsWith("Hips.position");
      return !isHipsPosition;
    });
  }

  removeRootMotionFromClip(loadedAnimations[4]);
  removeRootMotionFromClip(loadedAnimations[5]);
  //__________________________________________________________________________________________________________

  React.useEffect(() => {
    const dance = actions["dance"];
    const standUp = actions["standUp"];
    const stumble = actions["stumble"];
    stumble.loop = THREE.LoopOnce;
    stumble.clampWhenFinished = true;
    standUp.loop = THREE.LoopOnce;
    standUp.clampWhenFinished = true;

    dance.play();

    if (isColliding && dance.isRunning() === true) {
      dance.crossFadeTo(stumble, 0.8);
      stumble.reset().play();
      setCurrentAnimation("stumble");

      stumble.getMixer().addEventListener("finished", (event) => {
        if (event.action === stumble) {
          stumble.fadeOut(0.5);
          standUp.reset().fadeIn(0.5).play();
          setCurrentAnimation("standUp");
        }
      });

      standUp.getMixer().addEventListener("finished", (event) => {
        if (event.action === standUp) {
          standUp.fadeOut(0.5);
          dance.reset().fadeIn(0.5).play();
          setCurrentAnimation("dance");
        }
      });
    }
  }, [isColliding, actions]);

  React.useEffect(() => {
    if (
      currentAnimation === "stumble" &&
      actions["stumble"].isRunning() === true
    ) {
      setTimeout(() => {
        gsap.to(group.current.position, {
          duration: 2.0,
          y: group.current.position.y - 0.6,
          z: group.current.position.z - 0.7,
        });
      }, 500);
    }

    if (
      currentAnimation === "standUp" &&
      actions["standUp"].isRunning() === true
    ) {
      setTimeout(() => {
        gsap.to(group.current.position, {
          duration: 1.5,
          y: group.current.position.y + 0.6,
        });
      }, 700);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentAnimation]);

  return (
    <group ref={group} dispose={null}>
      <group name="Scene">
        <group name="Armature005" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <primitive object={nodes.mixamorigHips} ref={characterRef} />
          <skinnedMesh
            name="Ch46"
            geometry={nodes.Ch46.geometry}
            material={materials.Ch46_body}
            skeleton={nodes.Ch46.skeleton}
          />
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("/lazyAmy2.glb");
